# DataWise Desktop 架构决策记录 (ADR)

本文档记录关键架构决策及其理由。

---

## ADR-001: 采用事件驱动 + 命令模式架构

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: 架构组

### 背景
需要支持三种不同的 UI 框架（Tauri/egui/tui），同时保持业务逻辑 100% 复用。

### 决策
采用事件驱动 + 命令模式：
- UI 层通过 `Command` 发送指令
- Core 层通过 `UiEvent` 广播状态变化
- 使用 `tokio::sync::broadcast` 实现发布-订阅

### 理由
1. **解耦性**: UI 与业务逻辑完全分离
2. **可扩展性**: 新增 UI 框架无需修改 Core
3. **异步友好**: 天然支持并发和长时间任务
4. **测试性**: 可独立测试 Core 逻辑

### 后果
- ✅ 架构清晰，职责分明
- ⚠️ 需要额外的事件管理代码
- ⚠️ 调试时需要追踪事件流

---

## ADR-002: 选择 DuckDB 作为查询引擎

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: 架构组

### 背景
需要一个高性能的 OLAP 引擎，支持 SQL 查询和多种数据格式。

### 决策
使用 DuckDB 1.1 作为核心查询引擎。

### 理由
1. **性能**: 列式存储，针对分析查询优化
2. **零依赖**: 嵌入式数据库，无需外部服务
3. **格式支持**: 原生支持 CSV/Parquet/JSON
4. **Arrow 集成**: 零拷贝与 Arrow 互操作
5. **成熟度**: 生产级引擎，活跃维护

### 替代方案
- SQLite: 行式存储，分析性能较差
- DataFusion: 纯 Rust，但生态不如 DuckDB 成熟

### 后果
- ✅ 查询性能优异
- ✅ 开发效率高
- ⚠️ 依赖 C++ 库（编译时间较长）
- ⚠️ 需要关注 Rust 绑定的更新

---

## ADR-003: 使用 Apache Arrow 作为数据交换格式

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: 架构组

### 背景
需要在 Core 和 UI 之间高效传输大量数据。

### 决策
使用 Arrow RecordBatch 作为统一的数据交换格式。

### 理由
1. **零拷贝**: 列式内存布局，高效传输
2. **标准化**: 行业标准，跨语言支持
3. **DuckDB 集成**: 原生支持 Arrow
4. **生态**: 丰富的工具和库

### 后果
- ✅ 性能优异
- ✅ 内存效率高
- ⚠️ 学习曲线（列式思维）
- ⚠️ 序列化到 JSON（Tauri）有开销

---

## ADR-004: 改进进度事件结构

**日期**: 2025-11-13  
**状态**: 🟡 建议修改  
**决策者**: 架构组

### 背景
原设计 `Progress { pct: u8 }` 粒度过粗，无法显示详细进度信息。

### 决策
扩展 Progress 事件：
```rust
Progress { 
    pct: u8,
    bytes_processed: u64,
    total_bytes: u64,
    eta_seconds: Option<u32>,
}
```

### 理由
1. **用户体验**: 显示剩余时间和处理速度
2. **调试**: 更容易定位性能问题
3. **兼容性**: 向后兼容（新增字段）

### 后果
- ✅ 进度显示更友好
- ⚠️ 需要各导入器实现字节计数

---

## ADR-005: 内存管理策略 - 使用 Arc 共享所有权

**日期**: 2025-11-13  
**状态**: 🟡 建议修改  
**决策者**: 架构组

### 背景
`Finished(Vec<RecordBatch>)` 直接传递所有权可能导致内存峰值。

### 决策
改为 `Finished(Arc<Vec<RecordBatch>>)`，多个订阅者共享数据。

### 理由
1. **内存效率**: 避免数据复制
2. **多订阅者**: 支持多个 UI 同时订阅
3. **简单**: 相比流式传输实现简单

### 替代方案
- 流式传输: 更复杂，但内存控制更精细
- 按需查询: UI 通过 `get_batch(id)` 获取数据

### 后果
- ✅ 实现简单
- ✅ 内存占用可控
- ⚠️ 数据生命周期由最后一个订阅者决定

---

## ADR-006: Tauri 版本锁定策略

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: Tauri 团队

### 背景
Tauri 2.0 仍在快速迭代，API 可能变更。

### 决策
使用精确版本锁定：
```toml
tauri = "=2.0.5"  # 精确版本
```

### 理由
1. **稳定性**: 避免意外的 API 变更
2. **可重现**: 确保构建一致性
3. **可控升级**: 主动选择升级时机

### 后果
- ✅ 构建稳定
- ⚠️ 需要手动关注安全更新
- ⚠️ 可能错过性能改进

---

## ADR-007: egui 虚拟滚动实现策略

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: egui 团队

### 背景
egui 原生 Table 不支持百万行数据。

### 决策
使用 `egui_extras::TableBuilder` + 自定义懒加载：
```rust
TableBuilder::new(ui)
    .scroll_to_row(scroll_offset)
    .body(|mut body| {
        body.rows(row_height, visible_rows, |row_index, mut row| {
            // 仅渲染可见行
        });
    });
```

### 理由
1. **性能**: 仅渲染可见区域
2. **官方支持**: `egui_extras` 是官方库
3. **灵活性**: 可自定义渲染逻辑

### 后果
- ✅ 性能达标（60fps）
- ⚠️ 需要自己管理滚动状态

---

## ADR-008: 跨平台路径处理

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: Core 团队

### 背景
Windows 路径分隔符和 UNC 路径与 Unix 不同。

### 决策
统一使用 `std::path::PathBuf` + `dunce` crate：
```rust
use dunce::canonicalize;

fn normalize_path(path: &str) -> PathBuf {
    canonicalize(path).unwrap_or_else(|_| PathBuf::from(path))
}
```

### 理由
1. **标准化**: `dunce` 处理 Windows UNC 路径
2. **安全**: 避免路径遍历攻击
3. **兼容性**: 跨平台一致行为

### 后果
- ✅ 路径处理统一
- ✅ 减少平台特定 bug

---

## ADR-009: CI/CD 矩阵策略

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: DevOps 团队

### 决策
使用 GitHub Actions 矩阵构建：
```yaml
strategy:
  matrix:
    os: [ubuntu-latest, macos-latest, windows-latest]
    rust: [stable]
    ui: [core, tauri, egui, tui]
```

### 理由
1. **覆盖率**: 确保跨平台兼容性
2. **早期发现**: 及时发现平台特定问题
3. **自动化**: 减少手动测试负担

### 后果
- ✅ 质量保证
- ⚠️ CI 时间较长（并行执行缓解）

---

## ADR-010: 接口版本管理 - SemVer

**日期**: 2025-11-13  
**状态**: ✅ 已批准  
**决策者**: 架构组

### 决策
`protocol.rs` 变更遵循 SemVer：
- 新增字段/枚举变体 → 小版本（0.1 → 0.2）
- 删除/改名 → 大版本（0.x → 1.x）

所有 UI crate 锁定 Core 版本：
```toml
datawise-core = { path = "../datawise-core", version = "=0.1.0" }
```

### 理由
1. **兼容性**: 明确的兼容性保证
2. **协作**: UI 团队可预期变更影响
3. **稳定性**: 避免意外破坏

### 后果
- ✅ 接口稳定
- ⚠️ 需要严格的 PR 审查流程

---

**文档维护**: 每次重大架构决策需更新此文档  
**审查周期**: 每月回顾一次，评估决策有效性

